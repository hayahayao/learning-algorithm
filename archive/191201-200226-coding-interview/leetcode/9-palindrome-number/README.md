# 9-回文数

[Leetcode-9.回文数](https://leetcode-cn.com/problems/palindrome-number/)

## 题目描述

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

```
输入: 121
输出: true
```

示例 2:

```
输入: -121
输出: false
```

解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3:

```
输入: 10
输出: false
```

解释: 从右向左读, 为 01 。因此它不是一个回文数。

**进阶:**

你能不将整数转为字符串来解决这个问题吗？

## 解题思路

**1：每次都从两端各取一个数比较**

这种方法思路比较直接，难点就是数字头部的那一位怎么取到，解决：

先除10除10...这样操作得到数字的位数，从而能够得到头部要除的位数（我们将头部要除的这个数记为help，即`x / help`能够得到头部那一位数字）

之后就是正常操作，每次比完一轮要“把x两端的数字去掉”，具体操作见代码，画个图就能理解了

**2：反转后一半数字和前一半比较**

反转数字的算法可以参考[7：整数反转](./7-reverse-integer/README.md)，这个算法就是从末位开始一点点取余得到一位位数字

这个算法的难点在于如何判断反转的数字已经达到原数字的一半了，在官方题解里（不加证明地）给出了一个结论：

> 我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。

因为我也不会证明！！所以就不写实现了（？？）

## 实现

**1：每次都从两端各取一个数比较**

```javascript
var isPalindrome = function(x) {
    if (x < 0) return false
    let help = 1
    let tmp = x
    while (tmp >= 10) {
        help *= 10
        tmp = Math.floor(tmp / 10)
    }
    while (x > 0) {
        if (x % 10 !== Math.floor(x / help)) return false
        x = Math.floor((x % help) / 10)
        help /= 100
    }
    return true
};
```

**注意：**

- 取整取整取整
- 按照题目要求，负数直接返回 false 即可

